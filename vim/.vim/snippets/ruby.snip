snippet utf
    # -*- coding: utf-8 -*-

snippet she
	#!/usr/bin/env ruby

snippet y
	:yields: ${1:arguments}

snippet req
	require "${1}"${2}

snippet com
	# =>

snippet end
	__END__

snippet case
	case ${1:object}
	when ${2:condition}
		${3}
	end

snippet when
	when ${1:condition}
		${2}

snippet if
	if ${1:condition}
		${2}
	end

snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	end

snippet elsif
	elsif ${1:condition}
		${2}

snippet unless
	unless ${1:condition}
		${2}
	end

snippet while
	while ${1:condition}
		${2}
	end

snippet until
	until ${1:condition}
		${2}
	end

# Class and Module
snippet cla class .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end

snippet cla class .. initialize .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		def initialize(${2:args})
			${3}
		end


	end

snippet cla class .. < ParentClass .. initialize .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`} < ${2:ParentClass}
		def initialize(${3:args})
			${4}
		end


	end

snippet cla ClassName = Struct .. do .. end
	${1:`substitute(Filename(), '^.', '\u&', '')`} = Struct.new(:${2:attr_names}) do
		def ${3:method_name}
			${4}
		end


	end

snippet cla class BlankSlate .. initialize .. end
	class ${1:BlankSlate}
		instance_methods.each { |meth| undef_method(meth) unless meth =~ /\A__/ }

snippet cla class << self .. end
	class << ${1:self}
		${2}
	end
# class .. < DelegateClass .. initialize .. end

snippet cla-
	class ${1:`substitute(Filename(), '^.', '\u&', '')`} < DelegateClass(${2:ParentClass})
		def initialize(${3:args})
			super(${4:del_obj})

			${5}
		end


	end

snippet mod module .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end

snippet mod module .. module_function .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		module_function

		${2}
	end

snippet mod module .. ClassMethods .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		module ClassMethods
			${2}
		end

		module InstanceMethods

		end

		def self.included(receiver)
			receiver.extend         ClassMethods
		 	receiver.send :include, InstanceMethods
		end
	end

snippet r
	attr_reader :${1:attr_names}
# attr_writer

snippet w
	attr_writer :${1:attr_names}
# attr_accessor

snippet rw
	attr_accessor :${1:attr_names}

snippet Enum
	include Enumerable

	def each(&block)
		${1}
	end

snippet Comp
	include Comparable

	def <=>(other)
		${1}
	end

snippet Forw-
	extend Forwardable

snippet def
	def ${1:method_name}
		${2}
	end

snippet deft
	def test_${1:case_name}
		${2}
	end

snippet defs
	def self.${1:class_method_name}
		${2}
	end

snippet defmm
	def method_missing(meth, *args, &blk)
		${1}
	end

snippet defd
	def_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}

snippet defds
	def_delegators :${1:@del_obj}, :${2:del_methods}

snippet am
	alias_method :${1:new_name}, :${2:old_name}

snippet app
	if __FILE__ == $PROGRAM_NAME
		${1}
	end

snippet usai
	if ARGV.${1}
		abort "Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${3}
	end

snippet usau
	unless ARGV.${1}
		abort "Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${3}
	end

snippet array
	Array.new(${1:10}) { |${2:i}| ${3} }

snippet hash
	Hash.new { |${1:hash}, ${2:key}| $1[$2] = ${3} }

snippet file File.foreach() { |line| .. }
	File.foreach(${1:"path/to/file"}) { |${2:line}| ${3} }

snippet file File.read()
	File.read(${1:"path/to/file"})${2}

snippet Dir Dir.global() { |file| .. }
	Dir.glob(${1:"dir/glob/*"}) { |${2:file}| ${3} }

snippet Dir Dir[".."]
	Dir[${1:"glob/**/*.rb"}]${2}

snippet dir
	Filename.dirname(__FILE__)

snippet deli
	delete_if { |${1:e}| ${2} }

snippet fil
	fill(${1:range}) { |${2:i}| ${3} }

snippet flao
	inject(Array.new) { |${1:arr}, ${2:a}| $1.push(*$2)}${3}

snippet zip
	zip(${1:enums}) { |${2:row}| ${3} }

snippet dow
	downto(${1:0}) { |${2:n}| ${3} }

snippet ste
	step(${1:2}) { |${2:n}| ${3} }

snippet tim
	times { |${1:n}| ${2} }

snippet upt
	upto(${1:1.0/0.0}) { |${2:n}| ${3} }

snippet loo
	loop { ${1} }

snippet ea
	each { |${1:e}| ${2} }

snippet eab
	each_byte { |${1:byte}| ${2} }

snippet eac- each_char { |chr| .. }
	each_char { |${1:chr}| ${2} }

snippet eac- each_cons(..) { |group| .. }
	each_cons(${1:2}) { |${2:group}| ${3} }

snippet eai
	each_index { |${1:i}| ${2} }

snippet eak
	each_key { |${1:key}| ${2} }

snippet eal
	each_line { |${1:line}| ${2} }

snippet eap
	each_pair { |${1:name}, ${2:val}| ${3} }

snippet eas-
	each_slice(${1:2}) { |${2:group}| ${3} }

snippet eav
	each_value { |${1:val}| ${2} }

snippet eawi
	each_with_index { |${1:e}, ${2:i}| ${3} }

snippet reve
	reverse_each { |${1:e}| ${2} }

snippet inj
	inject(${1:init}) { |${2:mem}, ${3:var}| ${4} }

snippet map
	map { |${1:e}| ${2} }

snippet mapwi-
	enum_with_index.map { |${1:e}, ${2:i}| ${3} }

snippet sor
	sort { |a, b| ${1} }

snippet sorb
	sort_by { |${1:e}| ${2} }

snippet ran
	sort_by { rand }

snippet all
	all? { |${1:e}| ${2} }

snippet any
	any? { |${1:e}| ${2} }

snippet cl
	classify { |${1:e}| ${2} }

snippet col
	collect { |${1:e}| ${2} }

snippet det
	detect { |${1:e}| ${2} }

snippet fet
	fetch(${1:name}) { |${2:key}| ${3} }

snippet fin
	find { |${1:e}| ${2} }

snippet fina
	find_all { |${1:e}| ${2} }

snippet gre
	grep(${1:/pattern/}) { |${2:match}| ${3} }

snippet sub
	${1:g}sub(${2:/pattern/}) { |${3:match}| ${4} }

snippet sca
	scan(${1:/pattern/}) { |${2:match}| ${3} }

snippet max
	max { |a, b|, ${1} }

snippet min
	min { |a, b|, ${1} }

snippet par
	partition { |${1:e}|, ${2} }

snippet rej
	reject { |${1:e}|, ${2} }

snippet sel
	select { |${1:e}|, ${2} }

snippet lam
	lambda { |${1:args}| ${2} }

snippet do
	do |${1:variable}|
		${2}
	end

snippet :
	:${1:key} => ${2:"value"}${3}

snippet tas
	desc "${1:Task description}"
	task :${2:task_name => [:dependent, :tasks]} do
		${3}
	end

